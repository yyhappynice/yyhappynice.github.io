---
title: 从 Prompt 到上下文工程构建 Agent
date: 2025-10-18 14:38:18
categories:
  - ai笔记
tags:
  - 人工智能
  - 机器学习

---

>**以下学习过程分为四部分：**
>**结构化提示词工程** —— 如何工程化设计高效、可复用的提示词。
>**上下文工程与知识检索** —— 知识检索、生成与压缩上下文信息，产生高质量的知识背景。
>**工具函数的系统化设计** —— 设计并实现可供 Agent 调用的工具与接口。
>**Agent 规划与多 Agent** —— 构建任务规划与执行路径，实现闭环自动化。

## 结构化提示词工程

尽管 Context Engineering 是一个非常火的词，<u>但是如何写好 Prompt，依然是我们要入门的重点</u>。网上已经有非常多的提示词相关的内容， 但是从我的经验来看，我们可以把重点放在三个部分上：

* **提示词输入与输出的结构化**
* **复杂问题的链式与模块化设计**
* **提示词路由分发任务**

再配合上一些必要的 AI 框架或者工具，就能非常不错的完成我们的任务。

### 提示词输入与输出的结构化

在现在的开发 Agent 的过程中，尽管模型能生成一部分提示词，但是调提示词依然是工作的重点。我们希望模型输出的内容可以是 JSON、XML 或 Java 类，以便结合其它代码一起使用。

>提示词（Prompts）是用于引导 AI 模型生成**特定输出**而输入设计艺术与科学。通过对输入的精心设计与措辞，可以有效影响并控制模型的响应方向与结果， 使 AI 生成符合预期的输出。

我们可以直接看 Spring AI 文档的 Structured Output Converter 作为示例：

![Structured](https://github.com/user-attachments/assets/a6c4bc71-6fea-45ec-af9c-9c44fe6b0451)

图中的黄色部分即是两个核心：

**格式化的输入指令**
通常来说，我们需要结构提示词模板来动态生成提示词，采用结构化的文本来设计输入：

* **动态提示词模板（PromptTemplate）**。采用经典的模板引擎动态结合上下文，如 LangChain 里的 Jinja2，Spring AI 中的 StringTemplate。这种方式允许在运行时注入上下文、用户输入、系统状态等信息，实现灵活的 Prompt 构建。
* **结构化的文本结构**。为了保证 AI 输出的可靠性和可解析性，需要对提示词进行结构化设计，包括角色定位（Role）、任务描述（Task）、 约束条件（Constraints）、输出格式等。
* **示例驱动**。通过提供示例输入（Few-shots）与期望输出，可以显著提高模型输出的稳定性和一致性。诸如在实现 QA 的时候会给不同场景的实现示例。

**转换模型输出结果**

即针对不同的场景采用合适的输出格式，并实现对应的解析实现与**异常场景处理。**

* **领域特定的输出格式**。我们会基于场景的不同，采用 JSON、XML、YAML 或者 Markdown 等不同的设计，以用户体验更好的方式来展示。诸如： JSON 的优点是可直接序列化传输，但是不能实时渲染体验差，不够健壮。YAML 则能更好地处理流式的问题，并且传输成本更低。
* **解析实现**。从纯文本中解析出代码块，再进行反序列化与对象映射等处理。使用 Schema 验证（JSON Schema、XSD）确保模型输出字段类型和结构符合约定。
* **异常场景处理**。由于模型生成存在不确定性，输出可能存在缺失、类型错误或不符合约定格式的情况。诸如：字段缺失时，使用默认值或回退策略，可触发模型重试生成特定字段

在能力适当的时候，可以基于已有的数据等信息，微调/训练模型来提升在这方面的能力。

### 提示词路由分发任务

在复杂的 AI 系统中，尤其是多 Agent 或多模块协作的场景下，单个提示词往往无法完成所有任务。所以我们需要提示词路由：

![router](https://github.com/user-attachments/assets/2cc8a7db-aa0b-452a-afc8-977b5f0066d8)

>提示词路由（Prompt Routing） 是**在多任务、多 Agent 或复杂 AI 流程中，将任务拆分、分析输入并智能分配给最合适模型或子任务提示词的工程化模式。**

**其核心思想是**：<u>通过分析输入和上下文，动态决定信息处理路径、使用哪条提示词或调用哪个工具、子 Agent，从而实现非线性、条件化的任务执行</u>。以典型的 QA 场景为例：

* 非系统相关问题 → 直接告诉用户不支持该种类型的问题
* 基础知识问题 → 调用文档检索和 QA 模型
* 复杂分析问题 → 调用数据分析工具，再生成总结
* ……


通过提示词路由，系统可以根据问题类型智能选择最合适的处理方式，同时保持模块化和可扩展性。在一些 AI 框架里， 诸如 LangChain 里的 RouterChain 就可以提供类似的能力支持，还有诸如于 [Routing by semantic similarity](https://python.langchain.com/docs/how_to/routing/#routing-by-semantic-similarity) 这种方式。

### 复杂问题的链式与模块化设计

在有提示词路由的前提下，复杂问题可以通过**提示链（Prompt Chaining）**进行系统化拆解。提示链允许将一个大任务拆分为多个子任务， 每个子任务对应不同的提示词或模型调用，最后将结果整合。这种方式比较适合于有固定的流程，并且有一些步骤是可以跳过的。

![Chaining](https://github.com/user-attachments/assets/6f98007c-9126-486f-8fc4-289a2b87b50f)

这可以实现更好的模块化 设计：

* 每一个子任务都专注于处理特定阶段任务
* 可以按需重写某个子任务，增加或替换提示词
* 根据前一阶段输出动态调整后续提示词

以常见的软件需求为例，产品经理提出的想法可以通过提示链拆解为：

![拆截图](https://github.com/user-attachments/assets/b288ee10-eb67-460d-9ae4-e056c28406d7)

1. **创意收集**：收集产品创意与初步需求
2. **需求逻辑梳理**：理顺需求逻辑和功能优先级
3. **需求预排期**：形成初步的需求文档或任务列表
4. **需求定稿**：确认最终需求，生成正式文档

每个环节可以由不同的提示词或子 Agent 处理。例如，创意收集可借助具备搜索功能的 AI Agent，需求逻辑梳理可使用 Dify、 Copilot 365 等工具完成。最终，各环节按链式流程执行，同时保持模块化设计的灵活性，可根据需要随时调整或替换子任务。

