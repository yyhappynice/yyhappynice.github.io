---
title: Google gemini-cli 源码解构
date: 2025-11-18 16:57:08
categories:
  - ai笔记
tags:
  - 脚手架
---

> 随着大语言模型与开发工具链的深度融合，命令行终端正被重塑为开发者的AI协作界面。本文以 Google gemini-cli 为范本，通过源码解构，系统性分析其 **Agent 内核、ReAct 工作流、工具调用与上下文管理** 等核心模块的实现原理。为希望构建终端 Agent 的开发者，提供工程实现的系统化参考。

## 1、引言

命令行终端是开发者的核心工作区，也是许多开发者完成工作的首选工具。当前，大语言模型正在重塑命令行终端的能力，使终端不仅能完成命令执行，还能让开发者与智能体共同完成命令的协作、创造。

近期，Google 开源了其官方实现的命令行 AI 工作流工具——gemini-cli（https://github.com/google-gemini/gemini-cli），旨在将 AI 能力深度融入开发者的日常。它能分析庞大的代码库、自动化处理复杂的 Shell 指令和 Git 操作，还支持多模态交互。同时，它也是一个高度可扩展的平台，积极拥抱了模型上下文协议（MCP）、A2A等拓展协议。

本文的目标将不止于工具使用，我们将深入 gemini-cli 的源码，重点分析其整体架构，并解析其命令分发、工具调用和上下文管理等关键模块的实现原理，分析其AI Agent 的整体构建思路。

我们希望这次源码层面的分析，能为那些对 AI Agent 内部机制感到好奇，或是希望构建类似终端agent的开发者，提供一份务实且有价值的技术参考。

## 2、核心能力演示

在深入源码之前，让我们通过几个真实的场景，直观地感受 gemini-cli 如何将自然语言转化为实实在在的生产力。

### 2.1 场景一：自动化系统任务 —— 批量处理文件

这是最能体现命令行工具本质的场景。gemini-cli 可以将你用自然语言描述的复杂文件操作，直接翻译成可执行的命令。

**上下文**： 你的一个目录下堆满了jpg图片文件。

**用户输入**：`gemini > 将这个目录里的所有图片转换为 png 格式，并根据照片的 EXIF 数据里的拍摄日期来重命名它们。`

**gemini-cli的决策与执行路径**：展示了 gemini-cli，是一个能够规划、编码、诊断、并从失败中学习和迭代的 AI Agent。

![图片](https://github.com/user-attachments/assets/9c068b4b-34f4-4bda-aee1-bf9ac2ec9d06)

1. **规划与编码**：将任务拆解为四步计划，读取图片，转换格式，重命名新文件，删除原始文件。它没有直接生成复杂的 Shell 指令，判断出运用Python 脚本来解决问题。调用WriteFile，**在本地创建了一个 convert_images.py 脚本**。

2. **环境准备与自我纠错**：在执行前，它预判到需要 Pillow 库，并尝试用 pip 安装。命令失败后，它能理解错误并**自动切换到 pip3** 重试，展现了环境适应能力

3. **诊断与迭代**：首次运行脚本时，因图片缺少 EXIF 数据而失败。gemini-cli 捕获并理解了这个错误。它没有止步于此，而是**启动了代码修复流程**：它用 ReadFile 读取了自己刚写的代码，然后 **WriteFile** 进行了代码重构，增加了一个“使用文件修改时间作为备用方案”的逻辑。

4. **最终执行与验证**：最后，它**运行了更新后的脚本**，成功完成了图片格式转换与重命名。并通过 **ReadFolder** 命令验证了最终结果，形成了一个的闭环。

### 2.2 场景二：快速理解新项目 —— 深入分析代码库

面对一个陌生的代码库，它可以迅速帮助我们理清脉络。

**上下文**： 克隆了 gemini-cli 源代码至本地文件夹中

**用户输入**：`gemini > 本文件中有gemini-cli的源码，帮我梳理gemini-cli的整体架构。关键的目录和它们的作用分别是什么？`

**gemini-cli的决策与执行路径**：这个交互展示了 gemini-cli 作为信息分析助手的智能工作流。

![图片](https://github.com/user-attachments/assets/26c7c775-b216-4155-be38-2d63f7aa9fab)

1. **环境了解与信息收集**： 由于是全新会话，它首先意识到自己缺乏对当前环境的了解。它的第一步是**调用 ReadFolder 工具，扫描当前目录，获取一份完整的文件和文件夹“地图”**。

2. **模式识别与策略制定**： 在获取文件列表后，它利用内置的软件工程知识进行模式识别。当看到 docs/architecture.md 这个路径时，它迅速将用户的关键词“架构”与之关联，并制定出一条最高效的策略：**优先读取官方文档**，而非盲目分析代码。

3. **执行与信息提取**： 策略确定后，它立刻调用 ReadFile 工具，读取 docs/architecture.md 的内容。

4. **整合与结构化呈现**： 它没有直接返回文档原文，而是**完成了信息整合**。它将从文档中提取的信息与第一步查看的实际目录结构**进行交叉验证和补充**，最终生成了一份逻辑清晰、结构化的项目架构分析。

### 2.3 场景三：跨越模态的创造力 —— 从设计图到代码

这个场景将突破传统命令行的文本限制，理解视觉信息并将其转化为可执行的工作流。

**上下文**： 你的项目文件夹里有一张产品经理给的登录页面截图 login-mockup.png。

**用户输入**：`gemini > 这是我们的登录页面设计图 (login-mockup.png)，帮我生成对应的 HTML 和 CSS 代码，并用浏览器打开预览编码结果。`

**gemini-cli的决策与执行路径**： 这是从视觉到代码，再到预览的自动化工作流。

![图片](https://github.com/user-attachments/assets/99d2c2be-6631-43b4-8990-527a9d494f8f)

1. **任务拆解与规划**： 它首先将用户的复合指令拆解为三步计划：**分析图片、生成文件、打开浏览器预览**，展现了清晰的逻辑规划能力。

2. **视觉理解与代码翻译**： 它通过 ReadFile 加载图片，**其多模态模型解析出设计图中的布局、组件和样式**，然后基于这些视觉信息编写结构化的 HTML 和 CSS 代码。

3. **遵循最佳实践的文件操作**： 它将结构和样式分离，通过两次WriteFile调用，分别**创建了 index.html 和 style.css 两个文件**，遵循了前端开发的基本规范。

4. **无缝的工具链调用**： 最后，它**调用 Shell 工具执行 open 命令，自动在浏览器中打开了生成的页面**，完成了从一个创意原型到可交互预览的完整闭环。

通过这三个场景，我们看到 gemini-cli 扮演了三个关键角色：**能够自我纠错的 AI Agent、高效的代码分析师，以及理解视觉的创意开发者**。它的能力已远超传统命令行终端的范畴，不只是简单的命令执行者，而是**能将用户的复杂意图无缝转化为实际工作流的智能伙伴**。

那么，这一切强大能力的背后，究竟是怎样的架构设计在支撑呢？

## 3、架构设计与核心源码解析

### 3.1 核心架构与工作流程

![图片](https://github.com/user-attachments/assets/7935025b-ebee-4423-a382-d07d3c95256c)

如图所示，gemini-cli的架构分为**用户交互层、逻辑层、大模型服务与工具层**。整体上**围绕一个动态的推理与行动（ReAct）工作流构建**。其实现逻辑分布在**两个核心包中**：

`packages/core` 负责提供与大模型通信、执行工具等原子能力，而 `packages/cli` 作为上层协调者，负责驱动整个任务流程。

具体来说，**整个ReAct循环由cli包驱动**。当接收到用户指令后，它**首先调用 core 包进行“推理”，core 则将模型制定的行动计划返回给 cli**。收到计划后，**cli 再指令 core 执行工具**，并通过回调函数回收执行结果。cli 随即发起携带新上下文的下一轮“推理”，如此循环往复，直至任务完成。

这种**由 cli 驱动、core 执行的协作模式**，既保证了核心 AI 逻辑的可复用性，也赋予了界面层精细控制任务每一步状态的能力。

### 3.2 推理与行动循环

![图片](https://github.com/user-attachments/assets/89d8347b-3eea-47b8-8617-aee77d31f9ad)

如图，Gemini CLI 的核心是一个**由 packages/cli 驱动、packages/core执行的“推理-行动”（ReAct）循环**。这个循环并非简单的函数递归，而是通过一系列精心设计的 **Hooks和回调函数闭合的异步流程**。让我们从源码的视角，一步步拆解这个循环的实现机制。

#### 3.2.1 “用户输入”到“模型推理”

在交互模式下，每一次用户提交输入，都会触发 packages/cli/src/ui/hooks/useGeminiStream.ts 中的 **submitQuery** 函数。这是整个 ReAct 循环的入口。

1. **预处理与分发**：submitQuery 首先会调用 `prepareQueryForGemini` 函数。这是一个关键的预处理器，它负责**解析用户输入，处理 @文件引用和 /命令等前端指令**。如果指令可以在本地处理（如 /clear），流程就此终止；否则，它会将处理后的查询内容打包，准备发往模型。

2. **发起推理**：拿到处理好的查询后，**submitQuery** 会调用 `geminiClient.sendMessageStream()`，与 Gemini大模型建立一个流式连接。这标志着“推理”阶段的开始。

#### 3.2.2 “行动计划”到“工具执行”

模型在“推理”后，可能会返回一个包含行动计划的响应，即**工具调用请求（ToolCallRequest）。**

1. **接收与调度**：useGeminiStream 中的 processGeminiStreamEvents 函数负责监听事件流。当它收到 ToolCallRequest事件时，会将这些请求收集起来，并调用 scheduleToolCalls 函数。

2. **UI层的调度桥梁**：scheduleToolCalls 来自 packages/cli/src/ui/hooks/useReactToolScheduler.ts。这个 Hook不直接执行工具，它实例化了来自 core 包的 CoreToolScheduler 类，并将工具请求转发给它。

3. **Core层的执行核心**：真正的工具调度和执行逻辑位于 packages/core/src/core/coreToolScheduler.ts 的 CoreToolScheduler 类中。它的 schedule方法执行的关键步骤：

**排队**：确保同一时间只处理一批工具调用。

**验证**：检查工具是否存在、参数是否合法。

**确认**：对于敏感操作（如写文件），会挂起并等待用户在 UI 层面确认。

**执行**：调用工具自身的 `execute()` 方法，真正执行文件读写、命令运行等操作。

到此，cli 包成功地将“行动”指令委托给了 core 包去执行，并可以执行本地工具

#### 3.2.3 “观察”结果到再次“推理”

工具执行完毕后，结果需要被送回模型，以完成“观察”并开启下一轮“推理”。这个递归流程是通过回调链实现的。

1. **执行完成**：CoreToolScheduler 在所有工具执行完毕后，会调用一个名为 onAllToolCallsComplete 的回调函数，并将所有工具的执行结果作为参数。

2. **逐层返回**：这个回调函数会穿透 useReactToolScheduler，最终在 useGeminiStream hook 中被一个名为 handleCompletedTools 的函数接收。

3. **闭合循环**：handleCompletedTools 函数是整个循环的闭合点。它将所有工具的返回结果打包成模型需要的格式，然后——也是最关键的一步——再次调用 submitQuery 函数，并将工具结果作为新的查询内容，也是新一轮“观察”阶段的结束和新一轮“推理”的开始模型会根据工具的执行结果，决定是给出最终答案，还是规划下一步新的“行动” 。这个由回调驱动的循环会持续进行，直至最终任务完成。

### 3.3 工具调用与扩展

上一节我们看到，ReAct 循环的其中一个关键点在于模型能够决定何时调用工具。本节将深入探讨工具调用，以及 gemini-cli 是如何实现并安全执行它们的。整体逻辑可参考下图：

![图片](https://github.com/user-attachments/assets/8414b7f5-65b7-49cf-8a7a-21bb8c223b5d)

#### 3.3.1 工具的声明与实现

以 read_file 工具为例（位于packages/core/src/tools/read-file.ts）。

**声明** : 工具首先需要向大模型进行自我介绍。这是通过一个符合 JSON Schema 规范的配置对象完成的。它详细定义了工具的名称（如read_file）、功能描述（用于读取文件内容），以及最重要的——参数（如 absolute_path、offset等）。这份介绍是模型理解并决定如何使用该工具的依据。

**实现** : 当模型决定调用该工具后，其实际的执行逻辑则被封装在一个 Invocation 类中。该类的 execute()方法包含了真正的功能代码，例如调用文件系统 API 来读取文件。

## 6. 参考文献