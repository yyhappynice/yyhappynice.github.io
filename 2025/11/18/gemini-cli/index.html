<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="yyhappynice">





<title>Google gemini-cli 源码解构 | Hexo</title>



    <link rel="icon" href="/favicon.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    



        <!-- 背景图片自动替换样式 -->
        <style type="text/css">
            .back {
                position: fixed;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
                background-position: center center;
                background-repeat: no-repeat;
                background-size: cover;
                z-index: -1;
                transition: background-image 0.5s ease-in-out;
            }
        </style>
<meta name="generator" content="Hexo 8.0.0"></head>

<body>
    <!-- 背景图片容器 -->
    <div class="back"></div>

    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();

        // 背景图片自动替换功能
        (function () {
            // 获取当前时间并计算图片索引（每2分钟更换一次）
            function getImageIndex() {
                const minutes = new Date().getMinutes();
                return Math.floor((minutes + 1) / 2);
            }

            // 设置背景图片
            function setBackgroundImage() {
                const imageIndex = getImageIndex();
                const imageUrl = `/bgimg/${imageIndex}.jpg`;
                const backElement = document.querySelector('.back');

                if (backElement) {
                    backElement.style.backgroundImage = `url(${imageUrl})`;
                }
            }

            // 页面加载完成后设置背景图片
            // if (document.readyState === 'loading') {
            //     document.addEventListener('DOMContentLoaded', setBackgroundImage);
            // } else {
            //     setBackgroundImage();
            // }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">YuYi&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">YuYi&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
        
            <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        console.log('TOC: Document ready, initializing tocbot...');
        console.log('TOC: Content selector:', tocbot_default_config.contentSelector);
        console.log('TOC: Heading selector:', tocbot_default_config.headingSelector);

        // 检查内容容器是否存在
        var contentElement = document.querySelector(tocbot_default_config.contentSelector);
        console.log('TOC: Content element found:', contentElement);

        if (contentElement) {
            var headings = contentElement.querySelectorAll(tocbot_default_config.headingSelector);
            console.log('TOC: Found headings:', headings.length);

            try {
                tocbot.init(obj_merge(tocbot_default_config, {
                    collapseDepth: 1
                }));
                console.log('TOC: tocbot initialized successfully');
            } catch (error) {
                console.error('TOC: tocbot initialization failed:', error);
            }
        } else {
            console.error('TOC: Content element not found:', tocbot_default_config.contentSelector);
        }
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
                

                    
                        <article class="post-wrap">
                            <header class="post-header">
                                <h1 class="post-title">
                                    Google gemini-cli 源码解构
                                </h1>
                                
                                    <div class="post-meta">
                                        
                                            Author: <a itemprop="author" rel="author" href="/">yyhappynice</a>
                                            

                                                
                                                    <span class="post-time">
                                                        Date: <a href="#">十一月 18, 2025&nbsp;&nbsp;16:57:08</a>
                                                    </span>
                                                    
                                                        
                                                            <span class="post-category">
                                                                Category:
                                                                
                                                                    <a href="/categories/ai%E7%AC%94%E8%AE%B0/">ai笔记</a>
                                                                    
                                                            </span>
                                                            
                                    </div>
                                    
                            </header>

                            <div class="post-content">
                                <blockquote>
<p>随着大语言模型与开发工具链的深度融合，命令行终端正被重塑为开发者的AI协作界面。本文以 Google gemini-cli 为范本，通过源码解构，系统性分析其 <strong>Agent 内核、ReAct 工作流、工具调用与上下文管理</strong> 等核心模块的实现原理。为希望构建终端 Agent 的开发者，提供工程实现的系统化参考。</p>
</blockquote>
<h2 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h2><p>命令行终端是开发者的核心工作区，也是许多开发者完成工作的首选工具。当前，大语言模型正在重塑命令行终端的能力，使终端不仅能完成命令执行，还能让开发者与智能体共同完成命令的协作、创造。</p>
<p>近期，Google 开源了其官方实现的命令行 AI 工作流工具——gemini-cli（<a target="_blank" rel="noopener" href="https://github.com/google-gemini/gemini-cli%EF%BC%89%EF%BC%8C%E6%97%A8%E5%9C%A8%E5%B0%86">https://github.com/google-gemini/gemini-cli），旨在将</a> AI 能力深度融入开发者的日常。它能分析庞大的代码库、自动化处理复杂的 Shell 指令和 Git 操作，还支持多模态交互。同时，它也是一个高度可扩展的平台，积极拥抱了模型上下文协议（MCP）、A2A等拓展协议。</p>
<p>本文的目标将不止于工具使用，我们将深入 gemini-cli 的源码，重点分析其整体架构，并解析其命令分发、工具调用和上下文管理等关键模块的实现原理，分析其AI Agent 的整体构建思路。</p>
<p>我们希望这次源码层面的分析，能为那些对 AI Agent 内部机制感到好奇，或是希望构建类似终端agent的开发者，提供一份务实且有价值的技术参考。</p>
<h2 id="2、核心能力演示"><a href="#2、核心能力演示" class="headerlink" title="2、核心能力演示"></a>2、核心能力演示</h2><p>在深入源码之前，让我们通过几个真实的场景，直观地感受 gemini-cli 如何将自然语言转化为实实在在的生产力。</p>
<h3 id="2-1-场景一：自动化系统任务-——-批量处理文件"><a href="#2-1-场景一：自动化系统任务-——-批量处理文件" class="headerlink" title="2.1 场景一：自动化系统任务 —— 批量处理文件"></a>2.1 场景一：自动化系统任务 —— 批量处理文件</h3><p>这是最能体现命令行工具本质的场景。gemini-cli 可以将你用自然语言描述的复杂文件操作，直接翻译成可执行的命令。</p>
<p><strong>上下文</strong>： 你的一个目录下堆满了jpg图片文件。</p>
<p><strong>用户输入</strong>：<code>gemini &gt; 将这个目录里的所有图片转换为 png 格式，并根据照片的 EXIF 数据里的拍摄日期来重命名它们。</code></p>
<p><strong>gemini-cli的决策与执行路径</strong>：展示了 gemini-cli，是一个能够规划、编码、诊断、并从失败中学习和迭代的 AI Agent。</p>
<p><img src="https://github.com/user-attachments/assets/9c068b4b-34f4-4bda-aee1-bf9ac2ec9d06" alt="图片"></p>
<ol>
<li><p><strong>规划与编码</strong>：将任务拆解为四步计划，读取图片，转换格式，重命名新文件，删除原始文件。它没有直接生成复杂的 Shell 指令，判断出运用Python 脚本来解决问题。调用WriteFile，<strong>在本地创建了一个 convert_images.py 脚本</strong>。</p>
</li>
<li><p><strong>环境准备与自我纠错</strong>：在执行前，它预判到需要 Pillow 库，并尝试用 pip 安装。命令失败后，它能理解错误并<strong>自动切换到 pip3</strong> 重试，展现了环境适应能力</p>
</li>
<li><p><strong>诊断与迭代</strong>：首次运行脚本时，因图片缺少 EXIF 数据而失败。gemini-cli 捕获并理解了这个错误。它没有止步于此，而是<strong>启动了代码修复流程</strong>：它用 ReadFile 读取了自己刚写的代码，然后 <strong>WriteFile</strong> 进行了代码重构，增加了一个“使用文件修改时间作为备用方案”的逻辑。</p>
</li>
<li><p><strong>最终执行与验证</strong>：最后，它<strong>运行了更新后的脚本</strong>，成功完成了图片格式转换与重命名。并通过 <strong>ReadFolder</strong> 命令验证了最终结果，形成了一个的闭环。</p>
</li>
</ol>
<h3 id="2-2-场景二：快速理解新项目-——-深入分析代码库"><a href="#2-2-场景二：快速理解新项目-——-深入分析代码库" class="headerlink" title="2.2 场景二：快速理解新项目 —— 深入分析代码库"></a>2.2 场景二：快速理解新项目 —— 深入分析代码库</h3><p>面对一个陌生的代码库，它可以迅速帮助我们理清脉络。</p>
<p><strong>上下文</strong>： 克隆了 gemini-cli 源代码至本地文件夹中</p>
<p><strong>用户输入</strong>：<code>gemini &gt; 本文件中有gemini-cli的源码，帮我梳理gemini-cli的整体架构。关键的目录和它们的作用分别是什么？</code></p>
<p><strong>gemini-cli的决策与执行路径</strong>：这个交互展示了 gemini-cli 作为信息分析助手的智能工作流。</p>
<p><img src="https://github.com/user-attachments/assets/26c7c775-b216-4155-be38-2d63f7aa9fab" alt="图片"></p>
<ol>
<li><p><strong>环境了解与信息收集</strong>： 由于是全新会话，它首先意识到自己缺乏对当前环境的了解。它的第一步是<strong>调用 ReadFolder 工具，扫描当前目录，获取一份完整的文件和文件夹“地图”</strong>。</p>
</li>
<li><p><strong>模式识别与策略制定</strong>： 在获取文件列表后，它利用内置的软件工程知识进行模式识别。当看到 docs&#x2F;architecture.md 这个路径时，它迅速将用户的关键词“架构”与之关联，并制定出一条最高效的策略：<strong>优先读取官方文档</strong>，而非盲目分析代码。</p>
</li>
<li><p><strong>执行与信息提取</strong>： 策略确定后，它立刻调用 ReadFile 工具，读取 docs&#x2F;architecture.md 的内容。</p>
</li>
<li><p><strong>整合与结构化呈现</strong>： 它没有直接返回文档原文，而是<strong>完成了信息整合</strong>。它将从文档中提取的信息与第一步查看的实际目录结构<strong>进行交叉验证和补充</strong>，最终生成了一份逻辑清晰、结构化的项目架构分析。</p>
</li>
</ol>
<h3 id="2-3-场景三：跨越模态的创造力-——-从设计图到代码"><a href="#2-3-场景三：跨越模态的创造力-——-从设计图到代码" class="headerlink" title="2.3 场景三：跨越模态的创造力 —— 从设计图到代码"></a>2.3 场景三：跨越模态的创造力 —— 从设计图到代码</h3><p>这个场景将突破传统命令行的文本限制，理解视觉信息并将其转化为可执行的工作流。</p>
<p><strong>上下文</strong>： 你的项目文件夹里有一张产品经理给的登录页面截图 login-mockup.png。</p>
<p><strong>用户输入</strong>：<code>gemini &gt; 这是我们的登录页面设计图 (login-mockup.png)，帮我生成对应的 HTML 和 CSS 代码，并用浏览器打开预览编码结果。</code></p>
<p><strong>gemini-cli的决策与执行路径</strong>： 这是从视觉到代码，再到预览的自动化工作流。</p>
<p><img src="https://github.com/user-attachments/assets/99d2c2be-6631-43b4-8990-527a9d494f8f" alt="图片"></p>
<ol>
<li><p><strong>任务拆解与规划</strong>： 它首先将用户的复合指令拆解为三步计划：<strong>分析图片、生成文件、打开浏览器预览</strong>，展现了清晰的逻辑规划能力。</p>
</li>
<li><p><strong>视觉理解与代码翻译</strong>： 它通过 ReadFile 加载图片，<strong>其多模态模型解析出设计图中的布局、组件和样式</strong>，然后基于这些视觉信息编写结构化的 HTML 和 CSS 代码。</p>
</li>
<li><p><strong>遵循最佳实践的文件操作</strong>： 它将结构和样式分离，通过两次WriteFile调用，分别<strong>创建了 index.html 和 style.css 两个文件</strong>，遵循了前端开发的基本规范。</p>
</li>
<li><p><strong>无缝的工具链调用</strong>： 最后，它<strong>调用 Shell 工具执行 open 命令，自动在浏览器中打开了生成的页面</strong>，完成了从一个创意原型到可交互预览的完整闭环。</p>
</li>
</ol>
<p>通过这三个场景，我们看到 gemini-cli 扮演了三个关键角色：<strong>能够自我纠错的 AI Agent、高效的代码分析师，以及理解视觉的创意开发者</strong>。它的能力已远超传统命令行终端的范畴，不只是简单的命令执行者，而是<strong>能将用户的复杂意图无缝转化为实际工作流的智能伙伴</strong>。</p>
<p>那么，这一切强大能力的背后，究竟是怎样的架构设计在支撑呢？</p>
<h2 id="3、架构设计与核心源码解析"><a href="#3、架构设计与核心源码解析" class="headerlink" title="3、架构设计与核心源码解析"></a>3、架构设计与核心源码解析</h2><h3 id="3-1-核心架构与工作流程"><a href="#3-1-核心架构与工作流程" class="headerlink" title="3.1 核心架构与工作流程"></a>3.1 核心架构与工作流程</h3><p><img src="https://github.com/user-attachments/assets/7935025b-ebee-4423-a382-d07d3c95256c" alt="图片"></p>
<p>如图所示，gemini-cli的架构分为<strong>用户交互层、逻辑层、大模型服务与工具层</strong>。整体上<strong>围绕一个动态的推理与行动（ReAct）工作流构建</strong>。其实现逻辑分布在<strong>两个核心包中</strong>：</p>
<p><code>packages/core</code> 负责提供与大模型通信、执行工具等原子能力，而 <code>packages/cli</code> 作为上层协调者，负责驱动整个任务流程。</p>
<p>具体来说，<strong>整个ReAct循环由cli包驱动</strong>。当接收到用户指令后，它<strong>首先调用 core 包进行“推理”，core 则将模型制定的行动计划返回给 cli</strong>。收到计划后，<strong>cli 再指令 core 执行工具</strong>，并通过回调函数回收执行结果。cli 随即发起携带新上下文的下一轮“推理”，如此循环往复，直至任务完成。</p>
<p>这种<strong>由 cli 驱动、core 执行的协作模式</strong>，既保证了核心 AI 逻辑的可复用性，也赋予了界面层精细控制任务每一步状态的能力。</p>
<h3 id="3-2-推理与行动循环"><a href="#3-2-推理与行动循环" class="headerlink" title="3.2 推理与行动循环"></a>3.2 推理与行动循环</h3><p><img src="https://github.com/user-attachments/assets/89d8347b-3eea-47b8-8617-aee77d31f9ad" alt="图片"></p>
<p>如图，Gemini CLI 的核心是一个<strong>由 packages&#x2F;cli 驱动、packages&#x2F;core执行的“推理-行动”（ReAct）循环</strong>。这个循环并非简单的函数递归，而是通过一系列精心设计的 <strong>Hooks和回调函数闭合的异步流程</strong>。让我们从源码的视角，一步步拆解这个循环的实现机制。</p>
<h4 id="3-2-1-“用户输入”到“模型推理”"><a href="#3-2-1-“用户输入”到“模型推理”" class="headerlink" title="3.2.1 “用户输入”到“模型推理”"></a>3.2.1 “用户输入”到“模型推理”</h4><p>在交互模式下，每一次用户提交输入，都会触发 packages&#x2F;cli&#x2F;src&#x2F;ui&#x2F;hooks&#x2F;useGeminiStream.ts 中的 <strong>submitQuery</strong> 函数。这是整个 ReAct 循环的入口。</p>
<ol>
<li><p><strong>预处理与分发</strong>：submitQuery 首先会调用 <code>prepareQueryForGemini</code> 函数。这是一个关键的预处理器，它负责<strong>解析用户输入，处理 @文件引用和 &#x2F;命令等前端指令</strong>。如果指令可以在本地处理（如 &#x2F;clear），流程就此终止；否则，它会将处理后的查询内容打包，准备发往模型。</p>
</li>
<li><p><strong>发起推理</strong>：拿到处理好的查询后，<strong>submitQuery</strong> 会调用 <code>geminiClient.sendMessageStream()</code>，与 Gemini大模型建立一个流式连接。这标志着“推理”阶段的开始。</p>
</li>
</ol>
<h4 id="3-2-2-“行动计划”到“工具执行”"><a href="#3-2-2-“行动计划”到“工具执行”" class="headerlink" title="3.2.2 “行动计划”到“工具执行”"></a>3.2.2 “行动计划”到“工具执行”</h4><p>模型在“推理”后，可能会返回一个包含行动计划的响应，即<strong>工具调用请求（ToolCallRequest）。</strong></p>
<ol>
<li><p><strong>接收与调度</strong>：useGeminiStream 中的 processGeminiStreamEvents 函数负责监听事件流。当它收到 ToolCallRequest事件时，会将这些请求收集起来，并调用 scheduleToolCalls 函数。</p>
</li>
<li><p><strong>UI层的调度桥梁</strong>：scheduleToolCalls 来自 packages&#x2F;cli&#x2F;src&#x2F;ui&#x2F;hooks&#x2F;useReactToolScheduler.ts。这个 Hook不直接执行工具，它实例化了来自 core 包的 CoreToolScheduler 类，并将工具请求转发给它。</p>
</li>
<li><p><strong>Core层的执行核心</strong>：真正的工具调度和执行逻辑位于 packages&#x2F;core&#x2F;src&#x2F;core&#x2F;coreToolScheduler.ts 的 CoreToolScheduler 类中。它的 schedule方法执行的关键步骤：</p>
</li>
</ol>
<p><strong>排队</strong>：确保同一时间只处理一批工具调用。</p>
<p><strong>验证</strong>：检查工具是否存在、参数是否合法。</p>
<p><strong>确认</strong>：对于敏感操作（如写文件），会挂起并等待用户在 UI 层面确认。</p>
<p><strong>执行</strong>：调用工具自身的 <code>execute()</code> 方法，真正执行文件读写、命令运行等操作。</p>
<p>到此，cli 包成功地将“行动”指令委托给了 core 包去执行，并可以执行本地工具</p>
<h4 id="3-2-3-“观察”结果到再次“推理”"><a href="#3-2-3-“观察”结果到再次“推理”" class="headerlink" title="3.2.3 “观察”结果到再次“推理”"></a>3.2.3 “观察”结果到再次“推理”</h4><p>工具执行完毕后，结果需要被送回模型，以完成“观察”并开启下一轮“推理”。这个递归流程是通过回调链实现的。</p>
<ol>
<li><p><strong>执行完成</strong>：CoreToolScheduler 在所有工具执行完毕后，会调用一个名为 onAllToolCallsComplete 的回调函数，并将所有工具的执行结果作为参数。</p>
</li>
<li><p><strong>逐层返回</strong>：这个回调函数会穿透 useReactToolScheduler，最终在 useGeminiStream hook 中被一个名为 handleCompletedTools 的函数接收。</p>
</li>
<li><p><strong>闭合循环</strong>：handleCompletedTools 函数是整个循环的闭合点。它将所有工具的返回结果打包成模型需要的格式，然后——也是最关键的一步——再次调用 submitQuery 函数，并将工具结果作为新的查询内容，也是新一轮“观察”阶段的结束和新一轮“推理”的开始模型会根据工具的执行结果，决定是给出最终答案，还是规划下一步新的“行动” 。这个由回调驱动的循环会持续进行，直至最终任务完成。</p>
</li>
</ol>
<h3 id="3-3-工具调用与扩展"><a href="#3-3-工具调用与扩展" class="headerlink" title="3.3 工具调用与扩展"></a>3.3 工具调用与扩展</h3><p>上一节我们看到，ReAct 循环的其中一个关键点在于模型能够决定何时调用工具。本节将深入探讨工具调用，以及 gemini-cli 是如何实现并安全执行它们的。整体逻辑可参考下图：</p>
<p><img src="https://github.com/user-attachments/assets/8414b7f5-65b7-49cf-8a7a-21bb8c223b5d" alt="图片"></p>
<h4 id="3-3-1-工具的声明与实现"><a href="#3-3-1-工具的声明与实现" class="headerlink" title="3.3.1 工具的声明与实现"></a>3.3.1 工具的声明与实现</h4><p>以 read_file 工具为例（位于packages&#x2F;core&#x2F;src&#x2F;tools&#x2F;read-file.ts）。</p>
<p><strong>声明</strong> : 工具首先需要向大模型进行自我介绍。这是通过一个符合 JSON Schema 规范的配置对象完成的。它详细定义了工具的名称（如read_file）、功能描述（用于读取文件内容），以及最重要的——参数（如 absolute_path、offset等）。这份介绍是模型理解并决定如何使用该工具的依据。</p>
<p><strong>实现</strong> : 当模型决定调用该工具后，其实际的执行逻辑则被封装在一个 Invocation 类中。该类的 execute()方法包含了真正的功能代码，例如调用文件系统 API 来读取文件。</p>
<h4 id="3-3-2-统一的“工具注册表”"><a href="#3-3-2-统一的“工具注册表”" class="headerlink" title="3.3.2 统一的“工具注册表”"></a>3.3.2 统一的“工具注册表”</h4><p>所有内置或外部的工具，会被工具注册表ToolRegistry（位于 <code>packages/core/src/tools/tool-registry.ts</code>）来管理。</p>
<p>在应用启动时，Config模块会负责创建所有内置工具的实例，并逐一注册到表中。当需要与大模型交互时，系统会从注册表中提取所有工具的“声明”信息，统一提交给模型，让模型知道它当前拥有哪些可用的能力。同样，当模型请求执行某个工具时，调度器也会通过注册表来查找并执行它。</p>
<h4 id="3-3-3-安全执行的确认机制"><a href="#3-3-3-安全执行的确认机制" class="headerlink" title="3.3.3 安全执行的确认机制"></a>3.3.3 安全执行的确认机制</h4><p>对于 run_shell_command （实现位于packages&#x2F;core&#x2F;src&#x2F;tools&#x2F;shell.ts）这类可能造成风险的执行工具，gemini-cli 建立了一套安全确认机制，其决策逻辑位于 core 包，而 UI 交互则由 cli 包呈现。</p>
<ol>
<li><p><strong>决策点</strong>： 当一个高危工具被请求执行时，CoreToolScheduler 会首先调用该工具的 shouldConfirmExecute() 方法，以确定工具能否被执行。</p>
</li>
<li><p><strong>检查</strong>: 以shell工具为例，shouldConfirmExecute() 会进行检查：该命令是否在用户本次会话中已经授权过？</p>
</li>
<li><p><strong>请求确认</strong>: 如果授权检查未通过， CoreToolScheduler 会暂停执行，并发送信号至cli层。cli包接收到这个信号后，会渲染一个对话框，展示待执行的命令，并让用户做出是否确认执行的决定。</p>
</li>
</ol>
<p>这套机制确保敏感操作都在用户的明确授权下进行，同时通过会话内白名单等方式避免了不必要的重复确认。</p>
<h4 id="3-3-4-MCP拓展：连接外部工具"><a href="#3-3-4-MCP拓展：连接外部工具" class="headerlink" title="3.3.4 MCP拓展：连接外部工具"></a>3.3.4 MCP拓展：连接外部工具</h4><p>gemini-cli通过支持“<strong>模型上下文协议</strong>”（MCP），可以与任何外部工具服务器进行交互，从而获得扩展能力。</p>
<p>gemini-cli启动时，gemini-cli 会连接在配置中指定的 MCP 服务器，并请求对方<strong>提供其支持的工具列表</strong>。MCP服务器返回工具的声明信息后，<strong>gemini-cli 会将它们作为MCP工具注册到自己的ToolRegistry 中</strong>。（代码位于packages&#x2F;core&#x2F;src&#x2F;tools&#x2F; 目录下的 mcp-client-manager.ts）</p>
<p>当模型决定调用一个MCP外部工具时，其执行流程与内置工具不同是 execute() 方法，它通过初始化阶段建立的连接，将参数转发给MCP服务器。它会等待服务器返回执行结果，再将其递交给模型。（代码位于packages&#x2F;core&#x2F;src&#x2F;tools&#x2F; 目录下的 <strong>mcp-client.ts 、 mcp-tool.ts</strong> ）</p>
<p>通过这种方式，gemini-cli 将MCP工具整合进了自身的 ReAct循环中。</p>
<h3 id="3-4-上下文管理机制"><a href="#3-4-上下文管理机制" class="headerlink" title="3.4 上下文管理机制"></a>3.4 上下文管理机制</h3><p>在前两节中，我们分析了 gemini-cli 的推理循环与工具执行能力。要让这些能力发挥最大价值，其管理和利用上下文的能力必不可少。gemini-cli 通过<strong>多层次上下文管理机制</strong>，实现了<strong>短期会话记忆、长期知识注入，确保了交互的连贯性</strong>。</p>
<p><img src="https://github.com/user-attachments/assets/21a7af5b-84f1-4772-b6a3-4b4e0c63473b" alt="图片"></p>
<h4 id="3-4-1-会话历史"><a href="#3-4-1-会话历史" class="headerlink" title="3.4.1 会话历史"></a>3.4.1 会话历史</h4><p>基础的会话历史，保证了模型能记住你和它之间的对话。</p>
<ol>
<li><p><strong>UI 层</strong> : useGeminiStream hook (<strong>位于 packages&#x2F;cli&#x2F;src&#x2F;ui&#x2F;hooks&#x2F;useGeminiStream.ts</strong>)负责管理一个用于界面渲染的历史记录数组。当用户或模型产生新消息时，它会更新这个数组，让用户能在屏幕上看到对话流。</p>
</li>
<li><p><strong>core层</strong>: 模型记忆维护在调用Gemini的客户端代码 GeminiClient (位于 packages&#x2F;core&#x2F;src&#x2F;core&#x2F;client.ts) 及其内部的 GeminiChat 对象 (位于 packages&#x2F;core&#x2F;src&#x2F;core&#x2F;geminiChat.ts) 中。<strong>GeminiChat 内部维护着一个需要发送给 API 的、完整的对话历史。当它处理一个新的用户请求时，其sendMessageStream 方法会执行对历史会话的“读-写”操作</strong>：</p>
</li>
</ol>
<p>交互流程：</p>
<ol>
<li><p><strong>写入用户输入</strong>: 在向模型发送请求前，它首先将用户的最新输入追加到其内部历史记录的末尾。</p>
</li>
<li><p><strong>发送完整历史</strong>: 它将这个包含了最新输入的完整历史发送给模型。</p>
</li>
<li><p><strong>写入模型回复</strong>: 在接收到模型的完整回复后，它再将模型的回复追加到历史记录中。</p>
</li>
</ol>
<p>通过这种方式，利用GeminiChat 这个有状态的对象，每一轮对话都建立在完整的历史上下文之上，实现了连贯的交互。</p>
<h4 id="3-4-2-系统提示词"><a href="#3-4-2-系统提示词" class="headerlink" title="3.4.2 系统提示词"></a>3.4.2 系统提示词</h4><p>在大模型推理中，我们需要模型在整个会话中都记住一些核心背景信息，gemini cli除了内置的系统提示词（system prompt），还支持可选的用户自定义的上下文信息。</p>
<p>用户自定义的上下文，可通过 <strong>context.fileName 属性（配置文件.gemini&#x2F;config.yaml）来配置</strong>，可将用户提供的文件内容，与gemini-cli内置的系统提示词（system prompt）合并，形成一个在整个会话中保持不变的预设指令。在 gemini-cli 启动时，<strong>loadCliConfig 函数 (位于 packages&#x2F;cli&#x2F;src&#x2F;config&#x2F;config.ts) 会读取context.fileName指定的文件内容，并将其作为 userMemory 属性，存入 Config 对象中</strong>。</p>
<p>在创建聊天会话时，GeminiClient 会调用 getCoreSystemPrompt 函数 (<strong>位于 packages&#x2F;core&#x2F;src&#x2F;core&#x2F;prompts.ts</strong>)来构建完整的系统提示词（system prompt）。这个函数执行了如下逻辑：</p>
<ol>
<li><p><strong>加载基础系统提示词（system prompt）</strong>: 它首先会加载一个内置的字符串 basePrompt。这个 basePrompt 就是 gemini-cli 的原生系统提示，它详细定义了AI 助手的核心职责、工作流程、行为准则等。</p>
</li>
<li><p><strong>追加用户上下文</strong>: 它会检查 userMemory（即您文件中的内容）是否存在。如果存在，它会将其用分隔符（—）追加到 basePrompt 的末尾。</p>
</li>
</ol>
<p>这个<strong>合并了原生指令和用户自定义知识的、完整的系统提示词（system prompt）</strong>，会在API 请求上下文中被发送。模型会基于这个上下文来进行推理和行动。</p>
<h4 id="3-4-3-即时引入上下文"><a href="#3-4-3-即时引入上下文" class="headerlink" title="3.4.3 即时引入上下文"></a>3.4.3 即时引入上下文</h4><p>为了让用户能灵活地、即时地引入文件作为上下文，gemini-cli 提供了 @ 引用功能。这套机制是一个在请求发送前的预处理器中完成。</p>
<ol>
<li><p><strong>输入检测、解析</strong>: 用户输入会被<strong>useGeminiStream hook</strong> (位于 packages&#x2F;cli&#x2F;src&#x2F;ui&#x2F;hooks&#x2F;useGeminiStream.ts)检测输入中的 @ 符号，并将其交给 handleAtCommand 处理器（位于packages&#x2F;cli&#x2F;src&#x2F;ui&#x2F;hooks&#x2F;atCommandProcessor.ts）。</p>
</li>
<li><p><strong>复用存量工具</strong>: <strong>handleAtCommand 会解析出所有文件路径</strong>，然后调用上文提到的内置的文件读取工具，来读取这些文件的内容。</p>
</li>
<li><p><strong>组装上下文</strong>: <strong>它将读取到的文件内容，连同用户的原始提问，一起组装成一个完整 prompt</strong>。</p>
</li>
<li><p><strong>模型推理</strong>: 最后，这个包含了“<strong>即时上下文</strong>”的查询被发送给模型。这使得模型可以在当前这一轮对话中，精准地针对特定文件内容进行回答。</p>
</li>
</ol>
<h4 id="3-4-4-会话持久化"><a href="#3-4-4-会话持久化" class="headerlink" title="3.4.4 会话持久化"></a>3.4.4 会话持久化</h4><p>默认情况下，<strong>对话历史是存在于内存中的，关闭即消失</strong>。为了能跨越多次启动来保留对话，gemini-cli 提供了快照功能。</p>
<p>该功能通过 &#x2F;chat save 和 &#x2F;chat resume 命令来触发。</p>
<p>具体实现是通过Logger类（位于 packages&#x2F;core&#x2F;src&#x2F;core&#x2F;logger.ts）提供了 <strong>saveCheckpoint 和 loadCheckpoint 方法</strong>。通过<strong>读写本地文件实现上下文存储和读取</strong>。</p>
<p>通过这四种机制的协同工作，使得gemini-cli能<strong>处理流畅的即时对话，加载长期的背景知识、引用临时的文件内容，并能按需持久化和恢复整个对话</strong>，为用户提供了强大而灵活的上下文管理能力。</p>
<h2 id="4、架构思想与新范式"><a href="#4、架构思想与新范式" class="headerlink" title="4、架构思想与新范式"></a>4、架构思想与新范式</h2><p>上一节，我们深入源码的细节，揭示了 gemini-cli 的工作原理，同时也能逐步窥见代码背后一系列深思熟虑的架构决策。本章节将尝试对具体的技术实现进行梳理和提炼，分享对gemini-cli架构思想和技术选型的一些思考。</p>
<p><strong>我们将主要探讨以下几个方面</strong>：</p>
<ol>
<li>gemini-cli 是如何通过分层设计，构建其可移植的 Agent 内核的？</li>
<li>大模型在其运行时扮演了怎样的动态调度角色？</li>
<li>系统是如何通过指令确认机制，来构建人机协作模式的？</li>
<li>它又是如何通过开放协议，来构想其未来的工具生态的？</li>
</ol>
<p>通过对这些问题的探讨，希望能够揭示其设计背后的决策考量，为构建同类 AI Agent 的开发者提供一份有价值的架构参考。</p>
<h3 id="4-1-可复用的Agent-内核架构"><a href="#4-1-可复用的Agent-内核架构" class="headerlink" title="4.1 可复用的Agent 内核架构"></a>4.1 可复用的Agent 内核架构</h3><p>gemini-cli 在架构上对项目模块进行了明确的职责划分，将核心AI逻辑与前端交互界面彻底分离，其目的是构建一个与特定运行时环境解耦、可独立复用的Agent内核。</p>
<p>这一模式体现在 packages 目录下两个关键模块的划分上：</p>
<ol>
<li><strong>packages&#x2F;core (内核层)</strong>: 此模块<strong>封装了所有与 AI Agent 相关的原子能力和核心逻辑</strong>。它包含了<strong>与 Gemini API 的通信客户端 (GeminiChat)、工具的定义与注册机制 (ToolRegistry)、工具调度的执行器 (CoreToolScheduler)，以及会话日志与快照功能 (Logger)</strong>。内核层不包含任何与用户界面 (UI) 相关的代码，其 API 设计与具体应用无关的。</li>
<li><strong>packages&#x2F;cli (应用交互层)</strong>: 此模块是 core 内核的一个具体应用，负责将其能力适配到命令行终端这个特定的运行环境中。它的职责包括：<strong>解析命令行参数、使用 Ink 库渲染终端 UI、管理用户交互状态 (Node.js，基于Hooks和回调的事件驱动非阻塞 I&#x2F;O 模型)，以及调用 core 模块提供的 API 来驱动整个 ReAct 工作流</strong>。</li>
</ol>
<p>在我们前文的源码分析中，两个模块的职责边界很清晰：</p>
<ol>
<li><strong>ReAct 循环的实现</strong>：主逻辑 useGeminiStream Hook 存在于 cli 交互层，而调用的 sendMessageStream 等核心通信逻辑是由 core 内核层提供。</li>
<li><strong>安全确认机制</strong>：需要用户确认的决策由 core 内核层的 CoreToolScheduler 做出，但应用渲染确认框的 UI 逻辑则由 cli交互层实现。</li>
<li><strong>上下文处理</strong>：cli 交互层负责解析@ 符号这类特定于终端的便捷语法，并将解析出的文件内容，传递给 core 来构建最终的请求上下文。</li>
</ol>
<p>可复用的Agent 内核带来了较强的可移植性，作为一个独立的模块，可以被应用在任何项目中，如构建 web 服务、桌面应用等，它是可供开发者在不同场景下构建AI Agent的核心 SDK。</p>
<h3 id="4-2-LLM作为动态调度器的开发范式"><a href="#4-2-LLM作为动态调度器的开发范式" class="headerlink" title="4.2 LLM作为动态调度器的开发范式"></a>4.2 LLM作为动态调度器的开发范式</h3><p>在传统应用中，程序控制流由开发者通过 if&#x2F;else 等逻辑硬编码。而这里gemini-cli展示了大模型时代的编程范式，它将大语言模型作为应用的计划器、调度器。</p>
<p>开发者负责通过 ToolRegistry 声明式地注册一系列原子化的工具，但不编写具体的业务流程代码，而如何组合这些工具的决策权，交给了 LLM。当用户输入复杂指令时，LLM 在运行时动态生成一个执行计划，由具体代码（coreToolScheduler.ts）完成执行。</p>
<p>这种模式带来了两大优势：</p>
<ol>
<li><strong>能力的涌现</strong>：由于执行计划是LLM动态生成的，agent能够执行开发者从未明确编码过的行为，甚至自主决定编写并执行一个脚本来完成任务。</li>
<li><strong>业务逻辑复杂度降低</strong>：开发者只需不断增加原子能力工具，复杂的业务编排逻辑交给 LLM 来决定，整体代码复杂度得以降低。</li>
</ol>
<p>gemini-cli 将 LLM 作为动态调度器的设计，是当前 AI Agent 领域的核心实现范式。无论是 LangChain、LlamaIndex 等框架，还是 OpenAI、Grok 等模型提供商的官方工具调用功能，其底层逻辑都是一致的，即，将LLM做为一个主动的任务规划与函数调用引擎。</p>
<p>此架构范式让应用的能力上限不再受限于开发者预设的控制流，而是取决于 AI 在运行时对可用工具的动态组合与调用，为实现能处理复杂、多步任务，并具备一定自主性的通用 AI agent 提供了可参考的实现路径。</p>
<h3 id="4-3-指令确认与安全执行的人机共创模式"><a href="#4-3-指令确认与安全执行的人机共创模式" class="headerlink" title="4.3 指令确认与安全执行的人机共创模式"></a>4.3 指令确认与安全执行的人机共创模式</h3><p>当 LLM 成为动态调度器，具备自主规划和执行任务的能力时，问题也随之而来：如何确保AI的行为可控？</p>
<p>被业界广泛认可的解决方法是利用Human-in-the-Loop设计模式来构建自动化流程。HITL 强调在 AI 系统的关键决策点上，引入人类的监督、审核或最终授权，完成流程闭环。</p>
<p>gemini-cli 提供了将HITL理念工程化的范例。实现方案上并不是直接限制 AI模型本身的能力，而是通过指令确认与安全执行机制，在终端环境中实现了一种人机共创的协作模式。即，AI 负责提议与规划，人类保留最终的决策与执行权。</p>
<p>从源码层面看，为了保留人的决策权，CoreToolScheduler 在执行 run_shell_command 等高风险工具前，会暂停 ReAct 循环并向 cli 应用层发起授权请求。代码设计上做了职责分离：core 内核负责决策，cli层负责交互，利用了nodejs的事件驱动模型，实现了非阻塞式的确认流程。</p>
<p>另外，在上下文管理机制中，gemini-cli 允许我们使用 @file 实时引用文件，可以为 AI 注入明确的上下文信息，为人保留了更多的上下文控制权限、个人知识库信息的主导权。</p>
<p>可以说，为了实现HITL的设计理念，gemini-cli的采用的工程化手段，给了开发者构建人机协同的 AI Agent 提供了有价值的设计参考。</p>
<h3 id="4-4-从工具到agent协作的开放协议生态"><a href="#4-4-从工具到agent协作的开放协议生态" class="headerlink" title="4.4 从工具到agent协作的开放协议生态"></a>4.4 从工具到agent协作的开放协议生态</h3><p>gemini-cli 在扩展性上拥抱了开放协议MCP、A2A，在拓展性上不限于官方与开发者自建的插件工具。</p>
<ol>
<li><p><strong>MCP ，实现能力即插即用</strong>：通过MCP协议将工具解耦为可通过网络调用的独立服务。在 gemini-cli 的实现中，McpClientManager 在启动时会向配置的MCP服务器查询并加载工具的元信息，将其注册进本地的 ToolRegistry。当 LLM 决定调用时，将请求转发给对应 MCP 服务， 为gemini-cli 提供各类第三方能力集成的可能。</p>
</li>
<li><p><strong>A2A ，将gemini-cli的能力服务化以支持智能体间的协作</strong>：近期gemini-cli开源了对A2A的支持，在 packages&#x2F;a2a-server 中的实现。它将 gemini-cli 的核心能力封装成了一套可通过A2A协议调用的服务。尽管A2A整体生态尚处于早期阶段，但该实现对未来gemini-cli成为分布式Agent协作网络中的一部分，提供了可能性。</p>
</li>
</ol>
<p>gemini-cli 通过支持 MCP 和 A2A 这两大开放协议，展示了一种双向的扩展模式：既能作为客户端使用外部工具服务，也能作为服务端为其他应用提供 Agent 能力。开发者可以用任意语言构建工具或应用与 gemini-cli 无缝集成，共同组成一个更加开放和强大的 AI Agent 生态。</p>
<h2 id="5-总结与展望"><a href="#5-总结与展望" class="headerlink" title="5. 总结与展望"></a>5. 总结与展望</h2><p>从直观的能力演示到深入的源码剖析，我们一同拆解了 gemini-cli 的内部构造，并探讨了其背后的架构思想。至此，我们可以清晰地看到，gemini-cli 不止是一个功能丰富的命令行工具，它更是一个关于如何构建AI Agent 、有价值且可供参考的工程范例。</p>
<p>回顾全文，其核心设计亮点，可总结为如下四点：</p>
<ol>
<li><strong>代码架构</strong>：通过“核心层-交互层”的分离，提供了一个可移植的内核sdk，提供了易于复用与拓展的工程范例。</li>
<li><strong>运行模式</strong>：基于ReAct框架，将 LLM 作为大脑，实现了agent能力的“涌现”。</li>
<li><strong>人机协作</strong>：遵循了HITL设计理念，在 AI 的自主性与人的主导权间取得平衡，构建可信的共创模式。</li>
<li><strong>拓展生态</strong>：通过拥抱开放协议，支持工具能力的拓展，提供多agent间协作的无限潜力。</li>
</ol>
<p>展望未来，以gemini-cli为代表的终端Agent 可能往几个方向的发展：</p>
<ol>
<li><strong>与操作系统、桌面应用的深度集成联动</strong>：终端Agent可能打破终端本身的限制，通过与操作系统 API、被安装的各类应用的深度集成，理解屏幕交互信息，模拟人的操作，驱动任意桌面应用，执行跨系统应用工作流。</li>
<li><strong>更强大的长期记忆</strong>：随着模型能力持续进化，结合向量检索等技术，Agent 将建立更大规模的长期记忆能力，能基于对整个项目的全局上下文理解，做出更优的决策与执行。</li>
<li><strong>从单一智能体到分布式多智能体协作</strong>：随着A2A 等协议的成熟，更加繁荣的 Agent 生态将会出现。一个复杂的开发任务可能会被分发给多个专用 Agent 协作完成，发展为从命令执行、代码开发逐步拓展到自动化测试、CI&#x2F;CD流程、安全扫描等工业化生产要素完备的自动化研发Agents团队。</li>
</ol>
<p>最终，开发者终端agent将不再孤立，而是一个由 AI Agents 驱动的、高度协同的智能开发环境。<strong>开发者的角色也将从代码开发、执行者，转变为与AI agents协同共创的架构师</strong>。</p>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ol>
<li>gemini-cli 官方 GitHub 仓库:<a target="_blank" rel="noopener" href="https://github.com/google-gemini/gemini-cli">https://github.com/google-gemini/gemini-cli</a></li>
<li>Gemini API 函数调用官方文档: <a target="_blank" rel="noopener" href="https://ai.google.dev/gemini-api/docs/function-calling?hl=zh-cn&example=meeting">https://ai.google.dev/gemini-api/docs/function-calling?hl=zh-cn&amp;example=meeting</a></li>
<li>[论文]Yao, S., Zhao, J., Yu, D., Du, N., Shafran, I., Narasimhan, K., &amp; Cao, Y. (2022). ReAct: Synergizing Reasoning and Acting in Language Models. ArXiv, abs&#x2F;2210.03629.<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2210.03629">https://arxiv.org/abs/2210.03629</a></li>
<li>[论文]Madaan, A., Tandon, N., Gupta, P., Hallinan, S., Gao, L., Wiegreffe, S., Alon, U., Dziri, N., Prabhumoye, S., Yang, Y., Welleck, S., Majumder, B., Gupta, S., Yazdanbakhsh, A., &amp; Clark, P. (2023). Self-Refine: Iterative Refinement with Self-Feedback. ArXiv, abs&#x2F;2303.17651. <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2303.17651">https://arxiv.org/abs/2303.17651</a></li>
<li>[论文]Schick, T., Dwivedi-Yu, J., Dessì, R., Raileanu, R., Lomeli, M., Zettlemoyer, L., Cancedda, N., &amp; Scialom, T. (2023). Toolformer: Language Models Can Teach Themselves to Use Tools. ArXiv, abs&#x2F;2302.04761.<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2302.04761">https://arxiv.org/abs/2302.04761</a></li>
<li>模型上下文协议 (MCP) 规范：<a target="_blank" rel="noopener" href="https://github.com/modelcontextprotocol">https://github.com/modelcontextprotocol</a></li>
<li>Agent-to-Agent (A2A) 通信协议：<a target="_blank" rel="noopener" href="https://github.com/a2aproject/A2A">https://github.com/a2aproject/A2A</a></li>
<li>人机回路 (Human-in-the-Loop, HITL) 概念：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Human-in-the-loop">https://en.wikipedia.org/wiki/Human-in-the-loop</a></li>
<li>六边形架构 (端口与适配器): <a target="_blank" rel="noopener" href="https://alistair.cockburn.us/hexagonal-architecture/">https://alistair.cockburn.us/hexagonal-architecture/</a> <a target="_blank" rel="noopener" href="https://alistair.cockburn.us/he">https://alistair.cockburn.us/he</a></li>
</ol>

                            </div>

                            
                                <section class="post-copyright">
                                    
                                        <p class="copyright-item">
                                            <span>Author:</span>
                                            <span>yyhappynice</span>
                                        </p>
                                        
                                            
                                                <p class="copyright-item">
                                                    <span>Permalink:</span>
                                                    <span><a href="https://yyhappynice.github.io/2025/11/18/gemini-cli/">https://yyhappynice.github.io/2025/11/18/gemini-cli/</a></span>
                                                </p>
                                                
                                                    
                                                        <p class="copyright-item">
                                                            <span>License:</span>
                                                            <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                                                        </p>
                                                        
                                                            
                                                                <p class="copyright-item">
                                                                    <span>Slogan:</span>
                                                                    <span>Do you believe in <strong>DESTINY</strong>?</span>
                                                                </p>
                                                                

                                </section>
                                
                                    <section class="post-tags">
                                        <div>
                                            <span>Tag(s):</span>
                                            <span class="tag">
                                                
                                                    
                                                        <a href="/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"># 脚手架</a>
                                                        
                                                            
                                            </span>
                                        </div>
                                        <div>
                                            <a href="javascript:window.history.back();">back</a>
                                            <span>· </span>
                                            <a href="/">home</a>
                                        </div>
                                    </section>
                                    <section class="post-nav">
                                        
                                                
                                                    <a class="next" rel="next" href="/2025/11/06/langChainjs1/">LangChain 框架简介</a>
                                                    
                                    </section>

                                    <script src="https://giscus.app/client.js" data-repo="yyhappynice/yyhappynice.github.io"
  data-repo-id="MDEwOlJlcG9zaXRvcnkxNTk5NTcwNzA=" data-category="Announcements" data-category-id="DIC_kwDOCYjATs4Cwd0z"
  data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom"
  data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
  </script>

                        </article>
</div>
            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© yyhappynice | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>